# System Aliases
alias reboot='sudo reboot'
alias shutdown='sudo shutdown -h now'
alias c='clear'
alias h='history'
alias dfc='df -h .'
alias du='du -ch'
alias bat='batcat'
alias py='python3'

# Docker Aliases
alias cdc='cat docker-compose.yml'
alias ndc='nano docker-compose.yml'
alias rmdc='rm docker-compose.yml'
alias nenv='nano .env'
alias rmenv='rm .env'
alias dcu='docker compose up -d'
alias dcd='docker compose down'
alias dcr='docker compose restart'
alias dcp='docker compose pull'
alias dcl='docker compose logs -f'
alias dps="docker ps --format '{{.Names}}'"

# Functions
reload() {
    local shell_name
    shell_name=$(basename "$SHELL")
    case "$shell_name" in
        zsh)
            if [ -f "$HOME/.zshrc" ]; then
                source "$HOME/.zshrc"
                echo "Reloaded ~/.zshrc"
            else
                echo "No ~/.zshrc file found"
            fi
            ;;
        bash)
            if [ -f "$HOME/.bashrc" ]; then
                source "$HOME/.bashrc"
                echo "Reloaded ~/.bashrc"
            else
                echo "No ~/.bashrc file found"
            fi
            ;;
        *)
            echo "Unsupported shell: $shell_name"
            ;;
    esac
}

sstat() {
    RED="\033[1;31m"; GREEN="\033[1;32m"; YELLOW="\033[1;33m"
    BLUE="\033[1;34m"; MAGENTA="\033[1;35m"; CYAN="\033[1;36m"
    WHITE="\033[1;37m"; BRIGHT_CYAN="\033[0;96m"; BRIGHT_YELLOW="\033[0;93m"
    DIM="\033[0;37m"; RESET="\033[0m"
    read -r cpu u1 n1 s1 i1 io1 irq1 soft1 steal1 _ < /proc/stat
    total1=$((u1+n1+s1+i1+io1+irq1+soft1+steal1))
    sleep 1
    read -r cpu u2 n2 s2 i2 io2 irq2 soft2 steal2 _ < /proc/stat
    total2=$((u2+n2+s2+i2+io2+irq2+soft2+steal2))
    total_diff=$((total2 - total1))
    idle_diff=$((i2 - i1))
    CPU_USAGE=$(awk "BEGIN {printf \"%.2f\", ($total_diff - $idle_diff) * 100.0 / $total_diff}")
    MEM_TOTAL=$(grep MemTotal /proc/meminfo | awk '{print $2}')
    MEM_FREE=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
    MEM_USED=$((MEM_TOTAL - MEM_FREE))
    MEM_PERCENT=$(awk "BEGIN {printf \"%.2f\", $MEM_USED*100/$MEM_TOTAL}")
    MEM_USED_MB=$((MEM_USED / 1024))
    MEM_TOTAL_MB=$((MEM_TOTAL / 1024))
    UPTIME=$(uptime -p)
    if [ -f /sys/class/thermal/thermal_zone0/temp ]; then
        TEMP_C=$(( $(cat /sys/class/thermal/thermal_zone0/temp) / 1000 ))
        if [ $TEMP_C -ge 65 ]; then TEMP_COLOR=$RED
        elif [ $TEMP_C -ge 30 ]; then TEMP_COLOR=$YELLOW
        else TEMP_COLOR=$BLUE
        fi
        TEMP_DISPLAY="${TEMP_COLOR}${TEMP_C}°C${RESET}"
    else
        TEMP_DISPLAY="${DIM}N/A${RESET}"
    fi
    PUBLIC_IP=$(curl -s ifconfig.me 2>/dev/null || echo "N/A")
    PRIVATE_IP=$(hostname -I | awk '{print $1}' 2>/dev/null || echo "N/A")
    DISK_INFO=""
    MAX_PATH_LEN=$((COLUMNS - 40))  # leave space for size info
    while read -r line; do
        device=$(echo "$line" | awk '{print $1}')
        mount_point=$(echo "$line" | awk '{print $3}')
        [[ "$mount_point" =~ ^/(proc|sys|dev) ]] && continue
        disk_used=$(df -m "$mount_point" | awk 'NR==2 {print $3}')
        disk_total=$(df -m "$mount_point" | awk 'NR==2 {print $2}')
        disk_percent=$(df -h "$mount_point" | awk 'NR==2 {print $5}')
        if [ ${#mount_point} -gt $MAX_PATH_LEN ]; then
            mount_display="…${mount_point: -$((MAX_PATH_LEN-1))}"  # show last part
        else
            mount_display="$mount_point"
        fi

        DISK_INFO+="    ${BRIGHT_CYAN}├─${RESET} ${MAGENTA}$(basename "$device")${RESET} ${DIM}($mount_display)${RESET} ${BRIGHT_YELLOW}→${RESET} ${WHITE}${disk_used}MB${RESET}/${WHITE}${disk_total}MB${RESET} ${DIM}(${disk_percent})${RESET}\n"
    done < <(mount | grep '^/dev')
    clear
    HEADER_TEXT="SYSTEM STATUS"
    TERM_WIDTH=$COLUMNS
    HEADER_PAD=$(( (TERM_WIDTH - ${#HEADER_TEXT} - 2) / 2 ))  # 2 for spaces
    HEADER_LINE=$(printf "%*s" $HEADER_PAD "" | tr " " "═")
    echo -e "  ${CYAN}${HEADER_LINE} ${RED}${HEADER_TEXT}${RESET}${CYAN} ${HEADER_LINE}${RESET}\n"
    echo -e "  ${GREEN}● Uptime:${RESET}       ${WHITE}${UPTIME}${RESET}"
    echo -e "  ${GREEN}● Temperature:${RESET}  ${TEMP_DISPLAY}"
    echo -e "  ${GREEN}● CPU Usage:${RESET}    ${WHITE}${CPU_USAGE}%${RESET}"
    echo -e "  ${GREEN}● Memory:${RESET}       ${WHITE}${MEM_USED_MB}MB${RESET}/${WHITE}${MEM_TOTAL_MB}MB${RESET} ${DIM}(${MEM_PERCENT}%)${RESET}\n"

    echo -e "  ${YELLOW}▼ DISK USAGE:${RESET}"
    echo -e "$DISK_INFO"

    echo -e "  ${YELLOW}▼ CONNECTIVITY:${RESET}"
    echo -e "    ${BRIGHT_CYAN}├─${RESET} ${MAGENTA}Public IP:${RESET}  ${WHITE}${PUBLIC_IP}${RESET}"
    echo -e "    ${BRIGHT_CYAN}└─${RESET} ${MAGENTA}Private IP:${RESET} ${WHITE}${PRIVATE_IP}${RESET}"
    echo
}
gpsh() {
    # ───────────── Colors ─────────────
    RED="\033[1;31m"; GREEN="\033[1;32m"; YELLOW="\033[1;33m"
    CYAN="\033[1;36m"; WHITE="\033[1;37m"; MAGENTA="\033[1;35m"
    BRIGHT_CYAN="\033[0;96m"; RESET="\033[0m"

    COMMIT_MSG="$1"
    if [ -z "$COMMIT_MSG" ]; then
        echo -e "${RED}Error:${RESET} No commit message provided."
        echo -e "${YELLOW}Usage:${RESET} gpsh \"commit message\""
        return 1
    fi

    REPO_NAME=$(basename "$(git rev-parse --show-toplevel 2>/dev/null)")
    CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)

    if [ -z "$REPO_NAME" ]; then
        echo -e "${RED}Not a Git repository.${RESET}"
        return 1
    fi

    git add . >/dev/null 2>&1
    git commit -m "$COMMIT_MSG" >/dev/null 2>&1

    # ───────────── Header ─────────────
    clear
    HEADER_TEXT="GIT PUSH"
    TERM_WIDTH=$COLUMNS
    HEADER_PAD=$(( (TERM_WIDTH - ${#HEADER_TEXT} - 2) / 2 ))  # 2 for spaces
    HEADER_LINE=$(printf "%*s" $HEADER_PAD "" | tr " " "•")
    echo -e "  ${CYAN}${HEADER_LINE} ${RED}${HEADER_TEXT}${RESET}${CYAN} ${HEADER_LINE}${RESET}\n"

    # ───────────── Info ─────────────
    echo -e "  ${GREEN}● Repository:${RESET}      ${WHITE}${REPO_NAME}${RESET}"
    echo -e "  ${GREEN}● Branch:${RESET}          ${WHITE}${CURRENT_BRANCH}${RESET}"
    echo -e "  ${GREEN}● Commit Message:${RESET}  ${WHITE}${COMMIT_MSG}${RESET}\n"

    printf "%b" "  ${YELLOW}▼ Commit and push? (y/N):${RESET} "
    read -r CONFIRM

    if [[ "$CONFIRM" =~ ^[Yy]$ ]]; then
        echo -e "  ${BRIGHT_CYAN}├─${RESET} ${MAGENTA}Pushing to origin/${CURRENT_BRANCH}...${RESET}"
        git push origin "$CURRENT_BRANCH"
        echo -e "  ${BRIGHT_CYAN}└─${RESET} ${GREEN}Push complete${RESET}"
    else
        echo -e "  ${BRIGHT_CYAN}├─${RESET} ${RED}Push cancelled${RESET}"
        git reset --soft HEAD~1 >/dev/null 2>&1
        echo -e "  ${BRIGHT_CYAN}└─${RESET} ${YELLOW}Changes remain staged${RESET}"
    fi
    echo
}

gstat() {
    # ───────────── Colors ─────────────
    RED="\033[1;31m"; GREEN="\033[1;32m"; YELLOW="\033[1;33m"
    CYAN="\033[1;36m"; WHITE="\033[1;37m"; MAGENTA="\033[1;35m"
    BRIGHT_CYAN="\033[0;96m"; RESET="\033[0m"

    PULL_NEEDED=false
    REPO_NAME=$(basename "$(git rev-parse --show-toplevel 2>/dev/null)")
    CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)

    if [ -z "$REPO_NAME" ]; then
        echo -e "${RED}Not a Git repository.${RESET}"
        return 1
    fi

    git fetch --quiet 2>/dev/null
    LOCAL=$(git rev-parse @ 2>/dev/null)
    REMOTE=$(git rev-parse @{u} 2>/dev/null)

    if [ -z "$REMOTE" ]; then
        PULL_STATUS="${YELLOW}No remote tracking branch${RESET}"
    elif [ "$LOCAL" = "$REMOTE" ]; then
        PULL_STATUS="${GREEN}Up to date${RESET}"
    elif git merge-base --is-ancestor "$LOCAL" "$REMOTE" 2>/dev/null; then
        BEHIND=$(git rev-list --count HEAD..@{u} 2>/dev/null)
        PULL_STATUS="${RED}Pull needed (${BEHIND} commits behind)${RESET}"
        PULL_NEEDED=true
    elif git merge-base --is-ancestor "$REMOTE" "$LOCAL" 2>/dev/null; then
        AHEAD=$(git rev-list --count @{u}..HEAD 2>/dev/null)
        PULL_STATUS="${YELLOW}Push needed (${AHEAD} commits ahead)${RESET}"
    else
        PULL_STATUS="${RED}Diverged (fetch/merge needed)${RESET}"
        PULL_NEEDED=true
    fi

    LAST_COMMIT=$(git log -1 --pretty=format:"%ad^%s" --date=format:'%Y-%m-%d %H:%M:%S' HEAD)
    LAST_COMMIT_DATE=$(echo "$LAST_COMMIT" | cut -d'^' -f1)
    LAST_COMMIT_MESSAGE=$(echo "$LAST_COMMIT" | cut -d'^' -f2)

    # ───────────── Header ─────────────
    clear
    HEADER_TEXT="GIT STATUS"
    TERM_WIDTH=$COLUMNS
    HEADER_PAD=$(( (TERM_WIDTH - ${#HEADER_TEXT} - 2) / 2 ))
    HEADER_LINE=$(printf "%*s" $HEADER_PAD "" | tr " " "•")
    echo -e "  ${CYAN}${HEADER_LINE} ${RED}${HEADER_TEXT}${RESET}${CYAN} ${HEADER_LINE}${RESET}\n"

    # ───────────── Info ─────────────
    echo -e "  ${GREEN}● Repository:${RESET}      ${WHITE}${REPO_NAME}${RESET}"
    echo -e "  ${GREEN}● Branch:${RESET}          ${WHITE}${CURRENT_BRANCH}${RESET}"
    echo -e "  ${GREEN}● Remote Status:${RESET}   ${PULL_STATUS}\n"

    echo -e "  ${YELLOW}▼ LAST COMMIT:${RESET}"
    echo -e "    ${BRIGHT_CYAN}├─${RESET} ${MAGENTA}Date:${RESET}    ${WHITE}${LAST_COMMIT_DATE}${RESET}"
    echo -e "    ${BRIGHT_CYAN}└─${RESET} ${MAGENTA}Message:${RESET} ${WHITE}${LAST_COMMIT_MESSAGE}${RESET}\n"

    if $PULL_NEEDED; then
        printf "%b" "  ${YELLOW}▼ Pull is needed. Run 'git pull' now? (y/N):${RESET} "
        read -r choice
        if [[ "$choice" =~ ^[Yy]$ ]]; then
            echo -e "  ${BRIGHT_CYAN}└─${RESET} ${GREEN}Running 'git pull'...${RESET}"
            git pull
        else
            echo -e "  ${BRIGHT_CYAN}└─${RESET} ${YELLOW}Skipping pull${RESET}"
        fi
        echo
    fi
}
get_service_status() {
    local service_status=$(sudo systemctl is-active jellyfin)
    local service_enabled=$(sudo systemctl is-enabled jellyfin)
    local service_pid=$(sudo systemctl show --property=MainPID --value jellyfin)
    
    if [ "$service_status" = "active" ] && [ "$service_pid" -ne 0 ]; then
        SERVICE_STATUS="${GREEN}RUNNING${RESET}"
        PID_INFO="${DIM}(PID: ${service_pid})${RESET}"
        UPTIME=$(ps -p "$service_pid" -o etime= 2>/dev/null | xargs)
    else
        SERVICE_STATUS="${RED}STOPPED${RESET}"
        PID_INFO=""
        UPTIME=""
    fi
    
    if [ "$service_enabled" = "enabled" ]; then
        AUTO_START="${GREEN}ENABLED${RESET}"
    else
        AUTO_START="${RED}DISABLED${RESET}"
    fi
}